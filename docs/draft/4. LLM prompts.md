## LLM Prompts for Implementation

Below are the detailed prompts for a code-generation LLM to implement each step of the project:

### Prompt 1: Project Setup and Core Architecture

```
Create the initial project structure for a web-based tactical healing game. Focus on establishing the core architecture with the following components:

1. An HTML file with necessary containers for:
   - Game container
   - Party frames
   - Player UI (health/mana)
   - Spell bar
   - Sweet spot timing bar
   - Boss encounter area

2. Basic CSS for game layout with:
   - Fixed-width game container
   - Positioning for UI elements
   - Basic color scheme
   - Health/mana bar styling

3. A JavaScript module structure with:
   - Main entry point (index.js)
   - Core game loop module (game.js)
   - State management module (state.js)
   - Basic utility functions (utils.js)

Do not implement gameplay logic yet, only the structural foundation. Make sure the HTML, CSS, and JS files are properly linked.
```

### Prompt 2: Vroum Library Implementation

```
Implement a lightweight task scheduling library called "Vroum" for our tactical healing game. This library should provide the core functionality for our game loop and component management. Include the following:

1. A `Node` class that:
   - Can be extended by game entities
   - Maintains a list of child nodes
   - Has methods for adding/removing children
   - Includes an update method that propagates to children

2. A `Task` class for scheduling with:
   - Support for one-time and recurring tasks
   - Delay and duration parameters
   - Start, stop, and pause functionality
   - Callback execution on completion

3. A `Loop` class that:
   - Manages the game loop using requestAnimationFrame
   - Tracks delta time between frames
   - Updates all registered nodes
   - Processes scheduled tasks

Ensure the library is modular, efficient, and easy to use with our game components.
```

### Prompt 3: State Management System

```
Develop a state management system for our tactical healing game that handles game state changes in a predictable way. Implement:

1. A central game state store with:
   - Player state (health, mana, stats)
   - Party member states
   - Current encounter state
   - Spell states (cooldowns, charges)
   - Game progression state

2. A dispatcher that:
   - Processes actions with type and payload
   - Updates state via pure functions
   - Prevents direct state mutations
   - Emits change events

3. A subscription mechanism that:
   - Allows components to subscribe to state changes
   - Efficiently notifies only affected components
   - Provides helper methods for common state queries

Include utility functions for common state operations and ensure all state changes are traceable. This system should be the single source of truth for the game's state.
```

### Prompt 4: Command Parser for Development

```
Create a command parser system for our tactical healing game that will enable rapid development and testing. Implement:

1. A slash command parser that:
   - Detects commands starting with "/"
   - Parses arguments and options
   - Handles quoted arguments
   - Supports command aliases

2. A command registry that:
   - Allows registration of commands with descriptions
   - Validates command syntax
   - Provides help text

3. Implementation of basic commands:
   - /help - List all available commands
   - /set [stat] [value] - Modify player stats
   - /spawn [enemyType] - Create test enemies
   - /heal [amount] - Test healing
   - /damage [amount] - Test damage
   - /reset - Reset the current state

4. A simple command input UI with:
   - Text input field
   - Command history
   - Auto-completion suggestions

Ensure the command system integrates with our state management and can be easily extended with new commands.
```

### Prompt 5: Basic UI Components

```
Implement the core UI components for our tactical healing game using a DOM-based approach. Create:

1. A Component base class that:
   - Handles DOM element creation and management
   - Implements render and update methods
   - Manages event listeners
   - Connects to the state management system

2. Party frame components that:
   - Display health/mana bars for party members
   - Show character names and roles
   - Indicate selected target
   - Display active buffs/debuffs

3. Player status UI that:
   - Shows player health and mana
   - Displays relevant stats
   - Indicates global cooldown status
   - Shows active effects

4. Spell bar UI that:
   - Displays spell icons
   - Shows cooldown overlays
   - Indicates keybindings
   - Provides visual feedback on spell availability

Ensure components update efficiently in response to state changes and have clean separation of concerns. Focus on functionality rather than visual polish at this stage.
```

### Prompt 6: Spell System Fundamentals

```
Implement the core spell system for our tactical healing game. Create:

1. A Spell base class with:
   - Properties for cost, cast time, cooldown, and effects
   - Methods for starting/canceling casts
   - Cooldown tracking
   - Resource cost validation

2. A global cooldown mechanism that:
   - Triggers after most spell casts
   - Prevents rapid spell casting
   - Shows visual feedback
   - Allows certain spell types to bypass it

3. Spell effect system that:
   - Supports healing, damage, and buff effects
   - Applies effects to targets
   - Handles over-time effects
   - Calculates effectiveness based on stats

4. Implementation of basic spell types:
   - Heal: Direct single-target healing
   - Flash Heal: Fast emergency healing
   - Renew: Healing over time
   - Shield: Damage absorption
   - Smite: Minor damage dealing

Each spell should integrate with the state management system and trigger appropriate UI updates. Focus on the functional mechanics rather than visual effects.
```

### Prompt 7: Timing Mechanics Implementation

```
Implement the timing-based "sweet spot" mechanic for spell casting in our tactical healing game. Create:

1. A sweet spot UI component that:
   - Displays a horizontal bar with a moving pill
   - Shows the target sweet spot zone
   - Animates smoothly with configurable speed
   - Provides visual feedback for success/failure

2. A timing calculation system that:
   - Measures accuracy when the player activates a spell
   - Calculates tiered success levels (perfect, good, okay, poor)
   - Handles random variations in sweet spot movement
   - Adjusts difficulty based on player stats

3. Integration with the spell system to:
   - Modify spell effectiveness based on timing accuracy
   - Apply bonuses for perfect timing
   - Reduce effectiveness for poor timing
   - Trigger appropriate visual feedback

4. Configuration options for:
   - Sweet spot size
   - Movement speed
   - Difficulty scaling
   - Visual appearance

Ensure the system feels responsive and rewarding for player skill while maintaining a fair challenge level.
```

### Prompt 8: Targeting System

```
Implement the targeting system for our tactical healing game. Create:

1. A target selection mechanism that:
   - Allows clicking on party frames to select targets
   - Highlights the current target
   - Maintains target state in the game state
   - Provides methods for programmatic target changes

2. A target-then-cast workflow that:
   - Binds spells to the current target
   - Validates target appropriateness for each spell
   - Handles target loss during casting
   - Provides feedback when targeting is invalid

3. Smart targeting features like:
   - Auto-targeting the lowest health party member for healing spells
   - Remembering the last targeted party member
   - Contextual targeting based on spell type
   - Target cycling within the party

4. Visual indicators for:
   - Current target selection
   - Valid/invalid targets for the current spell
   - Casting feedback on targets
   - Target-specific information display

Ensure the targeting feels intuitive and responsive while integrating with the state management and spell systems.
```

### Prompt 9: Character System

```
Implement the character system for our tactical healing game. Create:

1. A Character base class with:
   - Health and mana properties
   - Basic stats (intellect, haste, critical strike, etc.)
   - Method for receiving healing/damage
   - Buff/debuff handling

2. Player character implementation that:
   - Extends the Character class
   - Handles player input
   - Manages the healer's resource systems
   - Tracks player-specific state

3. AI party members:
   - Tank character with threat generation and mitigation
   - DPS character with damage patterns
   - AI behavior for realistic combat patterns
   - Health/damage profiles appropriate to roles

4. Stats system that:
   - Calculates derived stats (healing power, mana regen, etc.)
   - Implements stat modifiers from buffs/gear
   - Provides methods for stat queries
   - Affects gameplay mechanics (cast speed, healing amount)

Ensure characters properly integrate with the state management system and respond appropriately to game events.
```

### Prompt 10: Boss Encounter System

```
Implement the boss encounter system for our tactical healing game. Create:

1. A Boss base class that:
   - Extends the Character class
   - Implements phased behavior
   - Manages ability cooldowns
   - Scales based on encounter difficulty

2. Boss ability system that:
   - Defines various attack types
   - Implements special abilities with unique effects
   - Creates encounter-specific mechanics
   - Signals upcoming abilities visually

3. Implementation of two distinct boss encounters:
   - Boss 1: Focuses on steady damage with occasional spikes
   - Boss 2: Emphasizes debuffs and positioning mechanics

4. Boss UI components that:
   - Display boss health and cast bar
   - Show upcoming ability indicators
   - Highlight active abilities
   - Provide visual feedback on ability effects

Ensure boss encounters create interesting healing challenges and integrate with the combat and state management systems.
```

### Prompt 11: Combat Logic

```
Implement the combat logic for our tactical healing game. Create:

1. Damage calculation system that:
   - Computes incoming damage based on attack power and mitigation
   - Handles critical hits and special damage types
   - Applies damage over time effects
   - Triggers appropriate state updates and events

2. Healing calculation system that:
   - Computes healing based on spell power and modifiers
   - Handles critical heals and healing bonuses
   - Processes overhealing
   - Applies healing over time effects

3. Buff/debuff system that:
   - Applies status effects to characters
   - Tracks duration and stacks
   - Calculates effect values based on stats
   - Handles buff refreshing and overwriting rules

4. Combat event system that:
   - Emits events for significant combat actions
   - Provides hooks for UI updates
   - Logs combat actions for review
   - Triggers conditional behaviors

Ensure these systems work together seamlessly to create engaging combat scenarios that require strategic healing decisions.
```

### Prompt 12: Dungeon Structure

```
Implement the dungeon structure for our tactical healing game. Create:

1. A node-based dungeon map system that:
   - Represents dungeons as connected nodes
   - Defines node types (boss, treasure, rest)
   - Structures progression through connected paths
   - Manages multiple dungeon levels

2. Dungeon navigation mechanism that:
   - Allows players to select connected nodes
   - Activates encounters when entering nodes
   - Tracks completed nodes
   - Manages level transitions

3. Dungeon state tracking that:
   - Saves dungeon progress
   - Records completed encounters
   - Manages dungeon-specific state
   - Handles dungeon reset/retry

4. Dungeon UI that:
   - Displays a minimap of the current dungeon
   - Shows available paths and node types
   - Indicates current position and progress
   - Provides navigation controls

Implement a simple 3-level dungeon with 3-4 nodes per level as a prototype. Ensure the dungeon system integrates with the encounter and state management systems.
```

### Prompt 13: Loot System

```
Implement a loot system for our tactical healing game. Create:

1. An Item base class with:
   - Properties for name, rarity, and stats
   - Methods for applying/removing stat effects
   - Equip requirements and restrictions
   - Special effects or procs

2. Loot table system that:
   - Defines boss-specific drop tables
   - Implements drop chance calculations
   - Handles item rarity distribution
   - Creates random item variations

3. Inventory system that:
   - Stores collected items
   - Allows equipping/unequipping items
   - Shows item comparison
   - Sorts by various criteria

4. Loot UI that:
   - Displays item details
   - Shows visual indicators for item rarity
   - Provides equip/discard options
   - Animates new item acquisition

Implement 10 initial items with varying rarities and stat focuses. Ensure the loot system integrates with the character stats and state management systems.
```

### Prompt 14: Character Progression

```
Implement the character progression system for our tactical healing game. Create:

1. Experience and leveling system that:
   - Awards XP for completing encounters
   - Defines level thresholds
   - Handles level-up events
   - Provides benefits for leveling

2. Stat allocation that:
   - Grants stat points on level-up
   - Allows distribution to different stats
   - Shows stat impact on performance
   - Permits reallocation

3. Equipment management that:
   - Defines gear slots (head, chest, hands, etc.)
   - Applies item stats when equipped
   - Handles set bonuses
   - Shows equipped item visualization

4. Character profile UI that:
   - Displays character level and progress
   - Shows allocated stats
   - Lists equipped items
   - Presents character achievement summary

Ensure the progression system provides meaningful advancement and integrates with the combat and state management systems.
```

### Prompt 15: Development Tools

```
Implement development tools to streamline testing and balancing for our tactical healing game. Create:

1. Enhanced slash command system that:
   - Adds commands for all major game systems
   - Supports complex parameter parsing
   - Provides detailed help documentation
   - Shows command execution feedback

2. Testing utilities that:
   - Allow spawning any boss encounter
   - Provide methods to trigger specific boss abilities
   - Enable instant creation of party scenarios
   - Support combat simulation

3. Parameter adjustment tools that:
   - Allow real-time modification of game balance values
   - Provide UI for tweaking timing difficulty
   - Support saving/loading balance presets
   - Display impact analysis for changes

4. Debug visualization that:
   - Shows hit boxes and trigger areas
   - Displays detailed combat calculations
   - Visualizes AI decision making
   - Graphs performance metrics

Ensure these tools are accessible during gameplay but don't interfere with the normal game experience.
```

### Prompt 16: Data Persistence

```
Implement data persistence for our tactical healing game. Create:

1. Local storage integration that:
   - Saves game state automatically
   - Loads saved games on startup
   - Handles multiple save slots
   - Implements save file management

2. Character profiles that:
   - Store player progress and stats
   - Save equipment and inventory
   - Record achievement history
   - Support multiple characters

3. Configuration system that:
   - Saves user preferences
   - Stores keybindings
   - Remembers UI settings
   - Handles default configurations

4. Data migration handling that:
   - Manages data format changes between versions
   - Provides fallbacks for missing data
   - Validates loaded data integrity
   - Handles corruption recovery

Ensure data is saved incrementally to prevent loss and that the system handles edge cases gracefully.
```

### Prompt 17: Final Integration

```
Complete the integration of all systems for our tactical healing game and implement final polish. Focus on:

1. System connections:
   - Ensure proper event propagation between components
   - Verify state consistency across systems
   - Implement any missing integration points
   - Create the central game controller

2. Performance optimization:
   - Improve rendering efficiency
   - Minimize unnecessary state updates
   - Optimize expensive calculations
   - Reduce memory usage

3. User experience polish:
   - Add smooth transitions between states
   - Implement visual feedback for all actions
   - Ensure consistent UI behavior
   - Add subtle animations and effects

4. Final gameplay balance:
   - Adjust difficulty curve
   - Balance resource management
   - Fine-tune sweet spot mechanics
   - Ensure satisfying progression

5. Basic sound effects for:
   - Spell casting
   - Healing and damage
   - UI interactions
   - Combat events

This final integration should create a cohesive game experience with all systems working together seamlessly.
```

## Implementation Strategy

When implementing this plan:

1. **Build incrementally**: Complete each step before moving to the next
2. **Test frequently**: Verify functionality after each implementation step
3. **Refactor as needed**: Don't hesitate to improve code structure as the project evolves
4. **Document your code**: Add comments and documentation to make future work easier
5. **Focus on core mechanics first**: Prioritize the timing and healing mechanics as they are central to gameplay
6. **Use placeholder assets**: Keep visual elements simple initially and improve them later
7. **Get feedback early**: Test the core gameplay loop as soon as possible

By following this detailed plan and the LLM prompts, you'll have a structured approach to building your tactical healing game, with each step building logically on the previous ones.